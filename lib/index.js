import{createCipheriv as a,createDecipheriv as m,randomBytes as h}from"node:crypto";import{Buffer as o}from"node:buffer";import{readFileSync as y,writeFileSync as c}from"node:fs";var f=class n{token;refreshT;tokenT;refreshtoken;lastrefreshTime;lastAccessTime;rtStoreKey="_refresh_token";key;iv=h(16);constructor(e){this.token=n.create(),this.lastAccessTime=Date.now(),this.tokenT=e?.timeWindow||3600,this.refreshT=e?.rtDays||30,this.rtStoreKey=e?.rtStoreKey||"_refresh_token",this.key=typeof e?.encryptionKey=="string"&&e.encryptionKey.length===32?e.encryptionKey:"",[this.lastrefreshTime,this.refreshtoken]=n.retrToken(this.rtStoreKey)}newAccessToken(e="",t){if(e){if(typeof e!="string")throw new Error("Data to encrypt must be string type");e=this.enc(e)}let r=Math.floor(Math.random()*((t?this.refreshtoken.length:this.token.length)-10+1));return String(r).length<2&&(r=(r||1)*10),r>this.token.length-15&&(r=r-77),setTimeout(()=>{n.timeDiff(this.lastAccessTime).diffSeconds>this.tokenT&&this.resetAccessToken()}),r+":"+(e+(t?this.refreshtoken:this.token).slice(r-10,r))}newRefreshToken(e="",t){return n.timeDiff(this.lastrefreshTime).day>this.refreshT&&this.resetRefreshToken(),this.newAccessToken(e,!0)}verifyAccessToken(e,t){let r=!0,[i,s]=(e||"").split(":");return!i||!s?!1:(s.length!==10&&(r=this.dec(s.slice(0,s.length-10)),s=s.slice(s.length-10,s.length)),(t?this.refreshtoken:this.token).slice(Number(i)-10,Number(i))===s&&r)}verifyRefreshToken(e){return this.verifyAccessToken(e,!0)}resetAccessToken(){this.token=n.create(),this.lastAccessTime=Date.now()}resetRefreshToken(){this.refreshtoken=n.create(),this.lastrefreshTime=Date.now(),c(this.rtStoreKey,this.refreshT+":"+this.refreshtoken)}static timeDiff(e){let t=Math.floor(Math.abs(new Date(Date.now()).getTime()-new Date(e).getTime())/1e3);return{day:Math.floor(t/86400)%30,diffSeconds:t}}static create(){return h(Math.max(Math.random()*999,499)).toString("hex")}static retrToken(e){let t=[Date.now(),n.create()];try{let r=y(e,{encoding:"utf8"});if(r){let[i,s]=r.split(":");t=[Number(i),s]}}catch{c(e,t[0]+":"+t[1])}return t}dec(e){if(!this.key)throw new Error("Encryption key must be 32 charaters");let t=m("aes-256-cbc",o.from(this.key),this.iv);return o.concat([t.update(o.from(e,"hex")),t.final()]).toString()}enc(e){if(!this.key)throw new Error("Encryption key must be 32 charaters");let t=a("aes-256-cbc",o.from(this.key),this.iv);return o.concat([t.update(e),t.final()]).toString("hex")}};export{f as SafeToken};
