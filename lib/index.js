import{createCipheriv as f,createDecipheriv as a,randomBytes as h}from"node:crypto";import{Buffer as o}from"node:buffer";import{readFileSync as y}from"node:fs";import{writeFile as m}from"node:fs/promises";var c=class s{token;refreshT;tokenT;refreshtoken;lastrefreshTime;lastAccessTime;rtStoreKey;key;iv=h(16);constructor(e){this.token=s.create(),this.tokenT=e?.timeWindow||3600,this.refreshT=e?.rtDays||30,this.lastAccessTime=Date.now(),this.rtStoreKey=e?.rtStoreKey,this.key=typeof e?.encryptionKey=="string"&&e.encryptionKey.length===32?e.encryptionKey:"",typeof e?.rtStoreKey=="string"?[this.lastrefreshTime,this.refreshtoken]=s.retrToken(e.rtStoreKey):(this.refreshtoken=s.create(),this.lastrefreshTime=Date.now())}newToken(e="",t){if(e){if(typeof e!="string")throw new Error("data to encrypt is invalid!, must be string type");e=this.enc(e)}let r=Math.floor(Math.random()*((t?this.refreshtoken.length:this.token.length)-10+1));return String(r).length<2&&(r=(r||1)*10),r>this.token.length-15&&(r=r-77),setTimeout(()=>{s.timeDiff(this.lastAccessTime).diffSeconds>this.tokenT&&this.resetAccessToken(),this.token=s.create()}),r+":"+(e+(t?this.refreshtoken:this.token).slice(r-10,r))}verifyToken(e,t){let r=!0,[i,n]=e.split(":");return n.length!==10&&(r=this.dec(n.slice(0,n.length-10)),n=n.slice(n.length-10,n.length)),(t?this.refreshtoken:this.token).slice(Number(i)-10,Number(i))===n&&r}verifyRefreshToken(e){return this.verifyToken(e,!0)}getRefreshToken(){return s.timeDiff(this.lastrefreshTime).day>this.refreshT&&this.resetRefreshToken(),this.newToken(void 0,!0)}resetAccessToken(){this.token=s.create(),this.lastAccessTime=Date.now()}resetRefreshToken(){this.refreshtoken=s.create(),typeof this.rtStoreKey=="string"&&m(this.rtStoreKey||"_refresh_token",this.refreshT+":"+this.refreshtoken),this.lastrefreshTime=Date.now()}static timeDiff(e){let t=Math.floor(Math.abs(new Date(Date.now()).getTime()-new Date(e).getTime())/1e3);return{day:Math.floor(t/86400)%30,diffSeconds:t}}static create(){return h(Math.max(Math.random()*999,499)).toString("hex")}static retrToken(e){try{let t=y(e||"_refresh_token",{encoding:"utf8"});if(t){let[r,i]=t.split(":");return[Number(r),i]}else return[Date.now(),s.create()]}catch{return[Date.now(),s.create()]}}dec(e){if(!this.key)throw new Error("Encryption key is invalid!, must be 32 charaters");let t=a("aes-256-cbc",o.from(this.key),this.iv);return o.concat([t.update(o.from(e,"hex")),t.final()]).toString()}enc(e){if(!this.key)throw new Error("Encryption key is invalid!, must be 32 charaters");let t=f("aes-256-cbc",o.from(this.key),this.iv);return o.concat([t.update(e),t.final()]).toString("hex")}};export{c as SafeToken};
